# BRK Sequence

BRK-sequence is a unified mechanism of CPU reaction to external interrupt signals (`/NMI`, `/IRQ`, `/RES`) and also to execution of instruction `BRK` (0x00).

In the main part has already been mentioned how the developers have approached the unification of this mechanism (injection of the operation code 0x00 in the register of instructions, etc.), in this section is a more detailed analysis.

Further consideration of the state is made with the assumption that input `RDY` = 1 (processor ready).

## BRK Software Model

General information for programmers, sufficient for a general understanding of the BRK-sequencing process.

|Cycle|Operation|
|---|---|
|T0|Load BRK opcode (instruction) / inject BRK (interrupt). Increment PC if a BRK instruction is executed directly|
|T1|Load and discard data. Increment PC if a BRK instruction is executed directly|
|T2|Put PCH on the stack|
|T3|Put PCL on the stack|
|T4|Put P on the stack|
|T5|Read interrupt vector address (low byte)|
|T6|Read interrupt vector address (high byte)|

## Powering up

The processor performs a special sequence (Pre-BRK) when the power is turned on.

## UB (0xFF), T1 (PHI1)

Top Part:

|State|Note|
|---|---|
|Interrupt processing||
|RESP=1|This is not an effect of /RES=0 because the input FF of the /RES pin is only updated during PHI2. This is the effect of the output `resp_latch`.|
|DORES=0|The input DORES_FF latch is only updated with the RESP signal during PHI2.|
|BRK6E=0|The value of the output latch is undefined, so through the inverter the value of BRK6E takes the value 0.|
|B_OUT=0|Although DORES = 0, the output latch value of the B flag is undefined and BRK6E = 0, so B_OUT = 0.|
|Dispatcher||
|/ready = 0|The value of the output /ready latch is updated during PHI2. At the time of power up the value of the latch is undefined, as a result /ready takes the value 0.|
|WR=1|WR is generated by a 3-NOR operation whose inputs (/ready, DORES, wr_latch) take the value 0. As a result WR = 1|
|FETCH=0|The value of the output latch of the FETCH circuit is not yet defined (updated during PHI2).|
|0/IR=1|Since FETCH = 0 and B_OUT = 0.|
|ENDS = 1|The values of the output latches of the ENDS circuit are undefined.|
|TRES1 = 1|Since ENDS = 1|
|TRESX=0|The TRESX circuit includes a latch whose value is not yet defined (PHI2). And through the inverter and NOR - TRESX as a result takes the value 0.|
|/TWOCYCLE=1|PD=0x00|
|TRES2=1|Since TRESX = 0|
|/T0 = 1|According to the circuit|
|/T1X = 0|According to the circuit|
|Extended cycle counter||
|/T2-/T5 = 1|TRES2 = 1|
|Decoder||
|44: INC NOP (TX), 60: ADC SBC (T1), 106: LSR ROR DEC INC DEX NOP (4x4 bottom right) (TX), 112: ADC SBC (T1)|Executes 0xFF/T1. The operation makes no sense because all random logic output latches are only updated during PHI2.|
|Registers||
|PD=0x00|As a result of 0/IR=1 the value of PD = 0x00|
|IR=0xFF|The value of the IR register is not updated (FETCH = 0), and it is arranged so that the decoder gets the value 0xFF|

Bottom Part:

As a result of the fact that the output commands are only loaded during PHI2 - their output values immediately after power up are undefined.

This causes almost all commands of the bottom part to be active (the lack of charge on the output latches' gates causes them to have 1 on the output). In this case the bottom part "goes crazy".

|State|Note|
|---|---|
|ADH/ABH, ADL/ABL|The address bus takes the value 0x0000|
|0/ADL0|1|
|0/ADL1|1|
|0/ADL2|0|
|0/ADH0, 0/ADH17|Both active commands cause the ADH bus to have a value of 0x00.|
|Y/SB, SB/Y, X/SB, SB/X, S/ADL, S/SB, SB/S, S/S|Y/SB, X/SB, SB/S, S/S have no effect, because the register is updated only during PHI2. As a result, the current value of registers X, Y, S simultaneously placed on the bus SB (for the register S - also on the bus ADL command S/ADL). The peculiarity of the register S is that the value from the output latch is output in inverted form. That is, on the bus SB and ADL placed value 0xFF (S = 0). But since the X/Y registers have already put value 0x00 on the bus before that, the ground wins and the SB bus takes value 0x00|
|NDB/ADD, DB/ADD, 0/ADD, SB/ADD, ADL/ADD, ADD/SB06, ADD/ADL, SB/AC, AC/SB, AC/DB, SB/DB, SB/ADH|AI: The 0/ADD, SB/ADD commands have the effect of loading 0 on the AI latch and simultaneously "grounding" the SB bus (SB/ADD opens the SB bus and 0/ADD zeroes it). But this makes no sense because the SB is already grounded by register operations. BI: There is no point in considering (?). ALU Output: There is no point in considering (?). ADD/SB7 = 0 because of the nature of its output latch (but it makes no sense now either)|
|ALU Operations|All disabled|
|/ACIN|TBD|
|/DAA|TBD|
|/DSA|TBD|
|#1/PC|TBD|
|ADH/PCH, PCH/PCH, PCH/ADH, PCH/DB, ADL/PCL, PCL/PCL, PCL/ADL, PCL/DB|TBD|
|RD = 0|According to WR = 1|
|DL/ADL, DL/ADH, DL/DB|Setting the DL/ADL and DL/ADH commands simultaneously causes the ADL/ADH buses to be shorted, causing them both to become 0x00 (the ADH is already grounded by the 0/ADH0, 0/ADH17 commands). DL/DB also causes the DB bus to be grounded. The DOR latch = 0x00.|
|Internal buses||
|SB|0x00|
|DB|0x00|
|ADL|0x00|
|ADH|0x00|

Phenomenon: All parts of the processor "go crazy", but miraculously all the operations cause the processor to write 0x00 to address 0x0000.

![FF_UB_T1_PHI1](/BreakingNESWiki/imgstore/ops/FF_UB_T1_PHI1.jpg)

## UB (0xFF), T1+T7 (PHI2)

|Component/Signal|State|
|---|---|
|Dispatcher|T0: 0, /T0: 1, /T1X: 0, 0/IR: 1, FETCH: 1, /ready: 0, WR: 0, ACRL1: 1, ACRL2: 1, T6: 0, T7: 1, ENDS: 0, ENDX: 0, TRES1: 0, TRESX: 0|
|Interrupts|/NMIP: 1, /IRQP: 1, RESP: 1, BRK6E: 0, BRK7: 1, DORES: 1, /DONMI: 0|
|Extra Cycle Counter|T1: 1, TRES2: 1, /T2: 1, /T3: 1, /T4: 1, /T5: 1|
|Decoder|44: INC NOP (TX), 60: ADC SBC (T1), 106: LSR ROR DEC INC DEX NOP (4x4 bottom right) (TX), 112: ADC SBC (T1)|
|Commands|ADD_SB7, ADD_SB06, PCH_ADH, PCL_ADL, PCL_DB, ADH_ABH, SB_DB, DBZ_Z, DB_N, ACR_C, AVR_V|
|ALU Carry In|0|
|DAA|1|
|DSA|1|
|Increment PC|0|
|Regs||
|IR|0xFF|
|PD|0x00|
|Y|0x00|
|X|0x00|
|S|0x00|
|AI|0x00|
|BI|0xFC|
|ADD|0xFF|
|AC|0x0A|
|PCL|0x00|
|PCH|0x00|
|ABL|0x00|
|ABH|0x00|
|DL|0x00|
|DOR|0x00|
|Flags|C: 0, Z: 0, I: 0, D: 0, B: 0, V: 0, N: 0|
|Buses||
|SB|0xFF|
|DB|0x00|
|ADL|0x00|
|ADH|0x00|

![FF_UB_T1_PHI2](/BreakingNESWiki/imgstore/ops/FF_UB_T1_PHI2.jpg)

## PreBRK (0x00), T0 (PHI1)

|Component/Signal|State|
|---|---|
|Dispatcher|T0: 1, /T0: 0, /T1X: 1, 0/IR: 1, FETCH: 1, /ready: 0, WR: 0, ACRL1: 1, ACRL2: 1, T6: 0, T7: 0, ENDS: 0, ENDX: 1, TRES1: 0, TRESX: 0|
|Interrupts|/NMIP: 1, /IRQP: 1, RESP: 1, BRK6E: 0, BRK7: 1, DORES: 1, /DONMI: 0|
|Extra Cycle Counter|T1: 0, TRES2: 1, /T2: 1, /T3: 1, /T4: 1, /T5: 1|
|Decoder|34: T0 ANY, 87: BRK RTI (T0), 94: BRK RTI (TX), 121: /IR6, 126: /IR7|
|Commands|S_S, DB_ADD, SB_ADD, SUMS, ADD_SB7, ADD_SB06, SB_AC, ADH_PCH, PCH_ADH, ADL_PCL, PCL_ADL, PCL_DB, ADH_ABH, SB_DB, DBZ_Z, DB_N, ACR_C|
|ALU Carry In|0|
|DAA|0|
|DSA|0|
|Increment PC|0|
|Regs||
|IR|0x00|
|PD|0x00|
|Y|0x00|
|X|0x00|
|S|0x00|
|AI|0xFF|
|BI|0x00|
|ADD|0xFF|
|AC|0xAA|
|PCL|0x00|
|PCH|0x00|
|ABL|0x00|
|ABH|0x00|
|DL|0x00|
|DOR|0x00|
|Flags|C: 1, Z: 1, I: 0, D: 0, B: 0, V: 0, N: 0|
|Buses||
|SB|0x00|
|DB|0x00|
|ADL|0x00|
|ADH|0x00|

![00_PreBRK_T0_PHI1](/BreakingNESWiki/imgstore/ops/00_PreBRK_T0_PHI1.jpg)

## PreBRK (0x00), T0 (PHI2)

|Component/Signal|State|
|---|---|
|Dispatcher|T0: 1, /T0: 0, /T1X: 1, 0/IR: 1, FETCH: 0, /ready: 0, WR: 0, ACRL1: 0, ACRL2: 1, T6: 0, T7: 0, ENDS: 0, ENDX: 1, TRES1: 0, TRESX: 0|
|Interrupts|/NMIP: 1, /IRQP: 1, RESP: 1, BRK6E: 0, BRK7: 1, DORES: 1, /DONMI: 0|
|Extra Cycle Counter|T1: 0, TRES2: 1, /T2: 1, /T3: 1, /T4: 1, /T5: 1|
|Decoder|34: T0 ANY, 87: BRK RTI (T0), 94: BRK RTI (TX), 121: /IR6, 126: /IR7|
|Commands|SUMS, ADD_ADL, ADH_ABH, ADL_ABL, DL_ADH, DL_DB|
|ALU Carry In|0|
|DAA|0|
|DSA|0|
|Increment PC|0|
|Regs||
|IR|0x00|
|PD|0x00|
|Y|0x00|
|X|0x00|
|S|0x00|
|AI|0xFF|
|BI|0x00|
|ADD|0xFF|
|AC|0xAA|
|PCL|0x00|
|PCH|0x00|
|ABL|0x00|
|ABH|0x00|
|DL|0x00|
|DOR|0x00|
|Flags|C: 1, Z: 1, I: 0, D: 0, B: 0, V: 0, N: 0|
|Buses||
|SB|0xFF|
|DB|0xFF|
|ADL|0xFF|
|ADH|0xFF|

![00_PreBRK_T0_PHI2](/BreakingNESWiki/imgstore/ops/00_PreBRK_T0_PHI2.jpg)

## PreBRK (0x00), T01 (PHI1)

|Component/Signal|State|
|---|---|
|Dispatcher|T0: 1, /T0: 0, /T1X: 0, 0/IR: 1, FETCH: 0, /ready: 0, WR: 0, ACRL1: 0, ACRL2: 0, T6: 0, T7: 0, ENDS: 0, ENDX: 1, TRES1: 0, TRESX: 0|
|Interrupts|/NMIP: 1, /IRQP: 1, RESP: 1, BRK6E: 0, BRK7: 1, DORES: 1, /DONMI: 0|
|Extra Cycle Counter|T1: 0, TRES2: 1, /T2: 1, /T3: 1, /T4: 1, /T5: 1|
|Decoder|34: T0 ANY, 87: BRK RTI (T0), 94: BRK RTI (TX), 121: /IR6, 126: /IR7|
|Commands|S_S, DB_ADD, SB_ADD, SUMS, ADD_ADL, ADH_PCH, ADL_PCL, ADH_ABH, ADL_ABL, DL_ADH, DL_DB|
|ALU Carry In|0|
|DAA|0|
|DSA|0|
|Increment PC|0|
|Regs||
|IR|0x00|
|PD|0x00|
|Y|0x00|
|X|0x00|
|S|0x00|
|AI|0xFF|
|BI|0x00|
|ADD|0xFF|
|AC|0xAA|
|PCL|0xFF|
|PCH|0x00|
|ABL|0xFF|
|ABH|0x00|
|DL|0x00|
|DOR|0x00|
|Flags|C: 1, Z: 1, I: 0, D: 0, B: 0, V: 0, N: 0|
|Buses||
|SB|0xFF|
|DB|0x00|
|ADL|0xFF|
|ADH|0x00|

![00_PreBRK_T01_PHI1](/BreakingNESWiki/imgstore/ops/00_PreBRK_T01_PHI1.jpg)

## PreBRK (0x00), T01 (PHI2)

|Component/Signal|State|
|---|---|
|Dispatcher|T0: 1, /T0: 0, /T1X: 0, 0/IR: 1, FETCH: 0, /ready: 0, WR: 0, ACRL1: 0, ACRL2: 0, T6: 0, T7: 0, ENDS: 0, ENDX: 1, TRES1: 0, TRESX: 0|
|Interrupts|/NMIP: 1, /IRQP: 1, RESP: 1, BRK6E: 0, BRK7: 1, DORES: 1, /DONMI: 0|
|Extra Cycle Counter|T1: 0, TRES2: 1, /T2: 1, /T3: 1, /T4: 1, /T5: 1|
|Decoder|34: T0 ANY, 87: BRK RTI (T0), 94: BRK RTI (TX), 121: /IR6, 126: /IR7|
|Commands|SUMS, ADD_ADL, ADH_ABH, ADL_ABL, DL_ADH, DL_DB|
|ALU Carry In|0|
|DAA|0|
|DSA|0|
|Increment PC|0|
|Regs||
|IR|0x00|
|PD|0x00|
|Y|0x00|
|X|0x00|
|S|0x00|
|AI|0xFF|
|BI|0x00|
|ADD|0xFF|
|AC|0xAA|
|PCL|0xFF|
|PCH|0x00|
|ABL|0xFF|
|ABH|0x00|
|DL|0x00|
|DOR|0x00|
|Flags|C: 1, Z: 1, I: 0, D: 0, B: 0, V: 0, N: 0|
|Buses||
|SB|0xFF|
|DB|0xFF|
|ADL|0xFF|
|ADH|0xFF|

![00_PreBRK_T01_PHI2](/BreakingNESWiki/imgstore/ops/00_PreBRK_T01_PHI2.jpg)

Further, until /RES takes value 1 - processor will execute in PreBRK loop T0+T1.

## Reset

TBD.

## NMI

TBD.

## IRQ

TBD.

## Mixed Interrupts

The situation when several interrupt input pins simultaneously capture an event.

TBD.

## BRK Opcode

TBD.
