# Общие мотивы схем

Хоть топология APU является "хендмейд", разработчики всё же применяли некоторые общие мотивы при разработке блоков.

В особенности это касается счётчиков, которые широко используются в APU (счетчики длительности, частоты и проч.)

В этом разделе содержится описание таких общих мотивов.

## Разряд счетчика

Данная схема представляет собой одну стадию (один разряд) счетчика.

Пример мотива разряда счетчика (транзисторная схема):

![20210224-141728](/BreakingNESWiki/imgstore/apu/20210224-141728.png)

Конкретно на этой схеме сигналы имеют следующий смысл:
- `RES` используется для очистки разряда (все разряды счетчика обычно очищаются одновременно)
- Сигнал `W4003` на картинке используется для загрузки нового значения. В данном случае вход подключен к `0` (то есть в счетчик всегда загружается 0), но также входное значение может приходить с DFF какого-нибудь регистра. Считайте что это своего рода сигнал `LOAD`
- `ACLK` используется для поддержания хранения значения разряда счетчика на затворах FET (реализует Flip-flop) и тактирования схемы. На схеме используется его инверсная версия (`/ACLK`), которая симметрично разведена по всему APU вместе с `ACLK`
- Сигнал с названием `FLOAD` на самом деле тут неудачно попал из схемы контроля, на самом деле это своего рода сигнал `STEP`, который дает команду счетчику выполнить инкремент. Пока сигнал `STEP` = 1 - счетчик производит инкремент каждый такт `ACLK`
- Входной и выходной перенос (`carry in` / `carry out`) помечены отдельно. Сигналы `carry` используют инверсную логику. У первого разряда (lsb) счетчика `carry in` обычно подключен к `1` (то есть нет входного переноса в прямой логике). У последнего разряда (msb) счетчика `carry out` либо никуда не разведен (floating), либо заворачивается назад в схему контроля счетчика для его перезагрузки
- Выходное значение (в прямой логике) выводится с помощью сигнала `val out` (показан отдельно)

На других схемах названия сигналов могут отличаться (кроме `RES`, он обычно всегда подключен к линии сброса для очистки счетчиков).

Анализ схемы:

![20210224-165911](/BreakingNESWiki/imgstore/apu/20210224-165911.png)

- В нижней левой части находится Flip-flop (FF), который регенерируется каждый цикл `ACLK` (когда `\ACLK` = 1 - выходное значение подается на вход, когда `\ACLK` = 0 - старое значение хранится на затворе левого FET). При этом левый FET может быть перегружен с помощью трёх Tristate: с помощью сигнала `RES` FET (и значение разряда счетчика) очищается, сигнал `W4003` (aka `LOAD`) позволяет сохранить в FF новое значение, а сигнал `FLOAD` (aka `STEP`) загружает в FF значение со схемы пересчёта. Соответственно нежелательно одновременно устанавливать сигналы `LOAD` и `STEP`, т.к. в этом случае схема начнет работать в режиме "победит земля" (Unpredictable behavour)
- Схема пересчёта состоит из мультиплексора (mux), управляющий вход которого помечен как "S", а селектирующие входы как 0 (когда S=0) и 1 (когда S=1). Вход мультиплексора управляется входным `carry`. Выход мультиплексора поступает на статическую защелку (FET на затворе которого хранится значение по традиции помечен зеленым квадратом). Выход со статической защелки поступает на вход FF только если разрешен пересчёт (управляющий сигнал `FLOAD` aka `STEP` равен 1)
- Выход разряда счетчика берется с выходного значения FF, а выходной `carry` получается путем комбинации выходного значения FF и входного `carry` с помощью вентиля nor (в правом нижнем углу на рисунке). Чтобы не насиловать схему лишними инверторами цепочка переноса выполнена в инверсной логике (в англ. литературе носит название "inverted carry chain").

Таблица состояний разряда счетчика, в зависимости от текущего значения FF и переноса (для удобства перенос в прямой логике):
|Старое значение FF|Carry in|Новое значение FF|Carry Out|
|---|---|---|---|
|0|0|1|0|
|0|1|0|1|
|1|0|0|1|
|1|1|1|1|

Вы можете самостоятельно подставить выходное значение FF и Carry в схему и проанализировать что получается :smiley:
