# H/V Декодер

H/V-декодер выбирает нужные пиксели и строки для H/V-логики.

Под "пикселем" понимается временной интервал, который базируется на PCLK. Не все "пиксели" отображаются как изображение, часть определяют различные управляющие порции сигнала, типа HSync, Color Burst и проч.

Принцип работы заключается в следующем:
- Входы находятся слева, выходы снизу. Входы для разрядов счетчика следуют в порядке сверху-вниз, начиная с msb, например: H8, /H8, H7, /H7 и т.д.
- Прямые и инверсные входы нужны чтобы проверить значение соответствующего разряда на `0` или `1`. Например, если разряд H8=1 и в декодере имеется транзистор, то выход "обнуляется" (неактивен).
- Каждый выход принимает значение `1` только для требуемых значений H или V
- H Decoder имеет 2 дополнительных входа: VB и BLNK, которые отсекают соответствующие выходы, когда VB=1 или BLNK=1
- Технически каждая линейка декодера представляет собой многовходовый вентиль NOR

## Декодер H NTSC

![ntsc_h](/BreakingNESWiki/imgstore/ntsc_h.png)

|Выход HPLA|Номера пикселей строки|Битовая маска|VB Tran|BLNK Tran|Смысловое значение/с чем связан|
|---|---|---|---|---|---|
|0|279|01101010011001010100| | |FPorch FF|
|1|256|01101010101010101000| | |FPorch FF|
|2|65|10100110101010100101| |yes|S/EV|
|3|0-7, 256-263|00101010101000000000| | |CLIP_O / CLIP_B|
|4|0-255|10000000000000000010|yes| |CLIP_O / CLIP_B|
|5|339|01100110011010010101| |yes|0/HPOS|
|6|63|10101001010101010101| |yes|EVAL|
|7|255|00010101010101010101| |yes|E/EV|
|8|0-63|10101000000000000001| |yes|I/OAM2|
|9|256-319|01101000000000000001| |yes|PAR/O|
|10|0-255|10000000000000000011|yes|yes|/VIS|
|11|Каждый 0..1|00000000000010100001| |yes|F/NT|
|12|Каждый 6..7|00000000000001010000| | |F/TB|
|13|Каждый 4..5|00000000000001100000| | |F/TA|
|14|320-335|01000110100000000001| |yes|/FO|
|15|0-255|10000000000000000001| |yes|F/AT|
|16|Каждый 2..3|00000000000010010000| | |F/AT|
|17|270|01101010100101011000| | |BPorch FF|
|18|328|01100110100110101000| | |BPorch FF|
|19|279|01101010011001010100| | |HBlank FF|
|20|304|01101001011010101000| | |HBlank FF|
|21|323|01100110101010010100| | |BURST/VSYNC FF|
|22|308|01101001011001101000| | |BURST/VSYNC FF|
|23|340|01100110011001101000| | |HCounter clear / VCounter step|

## Декодер V NTSC

![ntsc_v](/BreakingNESWiki/imgstore/ntsc_v.png)

|Выход VPLA|Номер строки|Битовая маска|Смысловое значение|
|---|---|---|---|
|0|247|000101010110010101| |
|1|244|000101010110011010| |
|2|261|011010101010011001| |
|3|241|000101010110101001| |
|4|241|000101010110101001| |
|5|0|101010101010101010| |
|6|240|000101010110101010| |
|7|261|011010101010011001| |
|8|261|011010101010011001| |

## Декодер H PAL

![pal_h](/BreakingNESWiki/imgstore/pal_h.png)

|Выход HPLA|Номера пикселей строки|Битовая маска|VB Tran|BLNK Tran|Смысловое значение/с чем связан|
|---|---|---|---|---|---|
|0|277|01101010011001100100| | |FPorch FF|
|1|256|01101010101010101000| | |FPorch FF|
|2|65|10100110101010100101| |yes|S/EV|
|3|0-7, 256-263|00101010101000000000| | |CLIP_O / CLIP_B|
|4|0-255|10000000000000000010|yes| |CLIP_O / CLIP_B|
|5|339|01100110011010010101| |yes|0/HPOS|
|6|63|10101001010101010101| |yes|EVAL|
|7|255|00010101010101010101| |yes|E/EV|
|8|0-63|10101000000000000001| |yes|I/OAM2|
|9|256-319|01101000000000000001| |yes|PAR/O|
|10|0-255|10000000000000000011|yes|yes|/VIS|
|11|Каждый 0..1|00000000000010100001| |yes|F/NT|
|12|Каждый 6..7|00000000000001010000| | |F/TB|
|13|Каждый 4..5|00000000000001100000| | |F/TA|
|14|320-335|01000110100000000001| |yes|/FO|
|15|0-255|10000000000000000001| |yes|F/AT|
|16|Каждый 2..3|00000000000010010000| | |F/AT|
|17|256|01101010101010101000| | |BPorch FF|
|18|4|10101010101001101000| | |BPorch FF|
|19|277|01101010011001100100| | |HBlank FF|
|20|302|01101001100101011000| | |HBlank FF|
|21|321|01100110101010100100| | |BURST/VSYNC FF|
|22|306|01101001011010011000| | |BURST/VSYNC FF|
|23|340|01100110011001101000| | |HCounter clear / VCounter step|

## Декодер V PAL

![pal_v](/BreakingNESWiki/imgstore/pal_v.png)

|Выход VPLA|Номер строки|Битовая маска|Смысловое значение|
|---|---|---|---|
|0|272|011010100110101010| |
|1|269|011010101001011001| |
|2|1|101010101010101001| |
|3|240|000101010110101010| |
|4|241|000101010110101001| |
|5|0|101010101010101010| |
|6|240|000101010110101010| |
|7|311|011010010110010101| |
|8|311|011010010110010101| |
|9|265|011010101001101001| |

## Симуляция

```python
class HDecoder:
	NumOuts = 24 		# Number of decoder outputs

	def __init__(self, ntsc):
		self.pla = [None] * 20
		if ntsc:
			self.pla[0]  = "001010101010000100000000"
			self.pla[1]  = "110001000100001001111111"
			self.pla[2]  = "111101101100000001111111"
			self.pla[3]  = "000000010000000000000000"
			self.pla[4]  = "110100101100000001011010"
			self.pla[5]  = "001001010000001000100101"
			self.pla[6]  = "111101000000001001110101"
			self.pla[7]  = "000000110000000000001010"
			self.pla[8]  = "011100000000001001100100"
			self.pla[9]  = "100001110000000000011011"
			self.pla[10] = "111101000000000000011111"
			self.pla[11] = "000000110000000001100000"
			self.pla[12] = "011001000001000010101100"
			self.pla[13] = "100000110000110001010011"
			self.pla[14] = "011000000001010000101011"
			self.pla[15] = "100001110000100011010100"
			self.pla[16] = "010000000000000001101011"
			self.pla[17] = "101001110000000000010100"
		else:
			self.pla[0]  = "001010101010000100100000"
			self.pla[1]  = "110001000100001001011111"
			self.pla[2]  = "111101101100000001111111"
			self.pla[3]  = "000000010000000000000000"
			self.pla[4]  = "110100101100000001111010"
			self.pla[5]  = "001001010000001000000101"
			self.pla[6]  = "111101000000001001110101"
			self.pla[7]  = "000000110000000000001010"
			self.pla[8]  = "011100000000001001101100"
			self.pla[9]  = "100001110000000000010011"
			self.pla[10] = "111101000000000001110111"
			self.pla[11] = "000000110000000000001000"
			self.pla[12] = "011001000001000011000110"
			self.pla[13] = "100000110000110000111001"
			self.pla[14] = "111000000001010001110101"
			self.pla[15] = "000001110000100010001010"
			self.pla[16] = "010000000000000001101011"
			self.pla[17] = "101001110000000000010100"
		# Common (VB & BLNK)
		self.pla[18] = "000010000010000000000000"
		self.pla[19] = "001001111111001100000000"			

	def sim(self, cnt, VB, BLNK):
		outs = [None] * self.NumOuts
		h = [None] * 9
		for n in range(9): 		# Get counter bits to speed up checking
			h[n] = (cnt >> n) & 1
		for i in range(self.NumOuts):
			# Initially, the output of a single PLA line is 1. A one-bit intersection will zero the output.
			out = 1
			for n in range(9):
				if self.pla[2*n][i] == '1' and h[8-n] != 0:
					out = 0
				if self.pla[2*n+1][i] == '1' and NOT(h[8-n]) != 0:
					out = 0
				if out == 0:
					break
			if self.pla[18][i] == '1' and VB != 0:
				out = 0
			if self.pla[19][i] == '1' and BLNK != 0:
				out = 0
			outs[i] = out
		return outs
    
    
class VDecoder:
	def __init__(self, ntsc):
		self.pla = [None] * 18
		if ntsc:
			self.pla[0]  = "000001000"
			self.pla[1]  = "001000011"
			self.pla[2]  = "001001011"
			self.pla[3]  = "110110100"
			self.pla[4]  = "001001011"
			self.pla[5]  = "110110100"
			self.pla[6]  = "001001011"
			self.pla[7]  = "110110100"
			self.pla[8]  = "001001011"
			self.pla[9]  = "110110100"
			self.pla[10] = "111111111"
			self.pla[11] = "000000000"
			self.pla[12] = "000111100"
			self.pla[13] = "111000011"
			self.pla[14] = "011111111"
			self.pla[15] = "100000000"
			self.pla[16] = "010001100"
			self.pla[17] = "101110011"
			self.NumOuts = 9
		else:
			self.pla[0]  = "0010010000"
			self.pla[1]  = "1100000111"
			self.pla[2]  = "1110010111"
			self.pla[3]  = "0001101000"
			self.pla[4]  = "1110010111"
			self.pla[5]  = "0001101000"
			self.pla[6]  = "1110010001"
			self.pla[7]  = "0001101110"
			self.pla[8]  = "0110010001"
			self.pla[9]  = "1001101110"
			self.pla[10] = "1011111110"
			self.pla[11] = "0100000001"
			self.pla[12] = "1011111001"
			self.pla[13] = "0100000110"
			self.pla[14] = "1111111001"
			self.pla[15] = "0000000110"
			self.pla[16] = "1001011000"
			self.pla[17] = "0110100111"
			self.NumOuts = 10

	def sim(self, cnt):
		outs = [None] * self.NumOuts
		v = [None] * 9
		for n in range(9): 		# Get counter bits to speed up checking
			v[n] = (cnt >> n) & 1
		for i in range(self.NumOuts):
			# Initially, the output of a single PLA line is 1. A one-bit intersection will zero the output.
			out = 1
			for n in range(9):
				if self.pla[2*n][i] == '1' and v[8-n] != 0:
					out = 0
				if self.pla[2*n+1][i] == '1' and NOT(v[8-n]) != 0:
					out = 0
				if out == 0:
					break
			outs[i] = out
		return outs
```
