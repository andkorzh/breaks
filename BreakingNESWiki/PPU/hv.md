# H/V Счётчики

H/V-счетчики считают количество пикселей в строке и количество строк, соответственно. H тикает от 0 до 340 (включая), V тикает от 0 до 261 (включая). Итого видимая и невидимая часть экрана представляет собой 262 строки по 341 пикселя каждая.

Технически счетчики состоят из 9 разрядов, поэтому могут считать от 0 до 0x1FF, но они никогда не считают полностью и ограничиваются максимальными значениями H и V. Для этого схема H/V FSM периодически сбрасывает их.

## Стадия счетчика

Рассмотрим работу одной стадии (разряда) счетчика на примере V-Counter.

![HV_stage](/BreakingNESWiki/imgstore/HV_stage.jpg)

![hv_stage2](/BreakingNESWiki/imgstore/hv_stage2.jpg)

![hv_stage2_annotated](/BreakingNESWiki/imgstore/hv_stage2_annotated.jpg)

- `/carry_in`: входной перенос в инверсной логике
- `/carry_out`: выходной перенос в инверсной логике
- `out`: выход одного разряда счетчика, в прямой логике
- `VC` (или `HC` у H-Counter): сигнал очистки всего счетчика. Данный способ очистки используется для управления очисткой счетчиков со стороны схемы H/V FSM.
- `RES`: сигнал общего сброса. Это глобальный сигнал сброса всех последовательностных схем PPU.
- `PCLK`: Pixel Clock

На изображении выделены транзисторы, которые формируют логические элементы.

Схема не очень сложная, за исключением необычной организации FF на базе двух 2-nor и двух мультиплексоров, которые формируют петлю FF.

Красивая схема из Logisim:

![hv_stage_logisim](/BreakingNESWiki/imgstore/hv_stage_logisim.jpg)

Смысл заключается в следующем:
- Виртуально текущее значение FF можно представить как выход мультиплексора, управляемого PCLK
- В состоянии PCLK=0 значение FF регенерируется старым значением (с учетом глобального сброса `RES`). Также при этом задействуется схема пересчета, которая выполнена на мультиплексоре Carry и статической защелке
- В состоянии PCLK=1 значение FF обновляется новым значением со схемы пересчёта

Таблица состояний для схемы пересчета:

|Текущее значение FF|carry_in (В прямой логике)|Новое значение на DLatch|
|---|---|---|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|0|

## Устройство H/V счетчиков

TODO: переделать, немного упростить

Вход V-counterа регулируется H-декодером. когда H=340, то вход V-Counter `/V_IN` устанавливается в 0 (`/carry_in` = 0), что дает возможность увеличить его значение на 1.
Выходной перенос каждого предыдущего бита заведен на входной перенос следующего, для формирования инвертированной carry-chain.

## Зачем нужна логика переноса

Счетчики включают в свой состав такой небольшой кусочек:

![CARRYH](/BreakingNESWiki/imgstore/CARRYH.jpg)

Зачем он нужен? Скорее всего, чтобы уменьшить propagation delay цепочки переносов.

## Симуляция

```python
class CounterStage:
	ff = 0					# This variable is used as a replacement for the hybrid FF built on MUX
	latch = DLatch()

	def sim(self, nCarry, PCLK, CLR, RES):
		self.ff = MUX(PCLK, NOR(NOT(self.ff), RES), NOR(self.latch.get(), CLR))
		self.latch.set (MUX(nCarry, NOT(self.ff), self.ff), NOT(PCLK))
		out = NOR(NOT(self.ff), RES)
		nCarryOut = NOR (NOT(self.ff), NOT(nCarry))
		return [ out, nCarryOut ]
```
