# Управляющие команды

**"Управляющие команды"** - это условное название большого количества контрольных линий, которые идут с верхней части процессора в нижнюю и управляют контекстом (регистрами, шинами и АЛУ). Ещё иногда я называю их "драйверами" (drivers).

Вот часть схемы процессора с несколькими контрольными линиями:

<img src="/BreakingNESWiki/imgstore/drivers.jpg" width="700px">

Каждая контрольная линия обычно содержит выходную защелку и иногда специальный транзистор-"отсекатель", который отключает линию в определенный полутакт (обычно часть линий отключается во время PHI2).

Большинство линий имеют названия вида `A/B`, это значит что линия "соединяет" `A` с `B`. Например SB/X означает что значение с внутренней шины SB помещается на регистр X.

Большинство команд идут в нижнюю часть процессора, но команды управления флагами не выходят за пределы рандомной логики, так как флаги располагаются в верхней части.

## Список

- **Команды управления регистрами**
- Y/SB: Y => SB
- SB/Y: SB => Y
- X/SB: X => SB
- SB/X: SB => X
- S/ADL: S => ADL
- S/SB: S => SB
- SB/S: SB => S
- S/S: Команда S/S активна, если неактивна команда SB/S. Эта команда просто "рефрешит" текущее состояние регистра S.
- **Команды управления АЛУ**
- ![FIXME](/BreakingNESWiki/imgstore/fixme.gif)
- **Команды управления счетчиком инструкций (PC)**
- 1/PC: сделать инкремент program counter
- ADH/PCH: ADH => PCH
- PCH/PCH: Если не выполняется ADH/PCH, то выполняется эта команда (рефрешить PCH)
- PCH/ADH: PCH => ADH
- PCH/DB: PCH => DB
- ADL/PCL: ADL => PCL
- PCL/PCL: Если не выполняется ADL/PCL, то выполняется эта команда (рефрешить PCL)
- PCL/ADL: PCL => ADL
- PCL/DB: PCL => DB
- **Команды управления шинами**
- ADH/ABH: ADH => ABH
- ADL/ABL: ADL => ABL
- 0/ADL0, 0/ADL1, 0/ADL2: используется для установки вектора прерываний, путем управления младшими 3 разрядами шины ADL. Например 0/ADL0 означает что 0-й разряд шины ADL устанавливается в 0. Значение с адресных регистров выводится на внешнюю шину адреса.
- 0/ADH0, 0/ADH17: сбросить часть разрядов шины ADH
- SB/DB: SB <=> DB, соединить две шины
- SB/ADH: SB <=> ADH
- **Команды управление data latch**
- ![FIXME](/BreakingNESWiki/imgstore/fixme.gif)
- **Команды управления регистром флагов**
- DB/P: load I, D, Z flags from internal data bus
- IR5/I: used to handle SEI/CLI instructions
- IR5/C: used to handle SEC/CLC instructions 
- DB/C: load C flag, from internal data bus
- ACR/C: put ALU carry out to C flag
- IR5/D: used to handle SED/CLD instructions
- DBZ/Z: put ALU zero result to Z flag
- 1/V: forced whenever input pad SO is set
- 0/V: used to handle CLV instruction
- DB/V: load V flag, from internal data bus
- AVR/V: put ALU overflow out to V flag
- DB/N: load N flag, from internal data bus
- P/DB: enables tri-state buffer, to connect flags output with internal data bus.

## Когда какие команды активны

Часть команд принудительно устанавливается в 0 (отключается) во время PHI2. Связано это с тем, что внутренние шины подзаряжаются во время PHI2, а регистры в это время обычно "рефрешатся". Ниже приведена таблица, галочкой помечаются команды который могут быть активны в указанный полутакт, а прочерком - когда команды принудительно отключаются.

|Команда|PHI1|PHI2|
|---|---|---|
|**Команды управления регистрами**|||
|Y/SB|✓|---|
|SB/Y|✓|---|
|X/SB|✓|---|
|SB/X|✓|---|
|S/ADL|✓|✓|
|S/SB|✓|✓|
|SB/S|✓|---|
|S/S|✓|---|

## Конфликтные состояния

Конфликтные состояние возникают когда несколько внутренних схем одновременно пихают свои значения на одну и ту же шину.

Например, при одновременном выполнении команд X/SB и Y/SB оба регистра будут помещены на шину SB и при этом возникает так называемый конфликт шины.

Конфликт шины разруливается по простому правилу - "побеждает земля". То есть те разряды, которые равны 0 перебивают все единичные разряды.

Например, если значение X = 0x33 (00110011), а значение Y = 0x12 (00010010), то в результате одновременного выполнения команд X/SB и Y/SB значение шины будет равно 0x12 (00010010).

## Симуляция конфликтных состояний

При обработке команд выгрузки значений на шины нужно делать не обычное присваивание типа SB = X, а применять следующий трюк:

```c
SB = 0xFF;     // bus precharged (not connected)
if (X/SB) SB &= X;
if (Y/SB) SB &= Y;
```

В результате чего единичные разряды шины разрядятся и возможные конфликты шины будут устранены.

## Курица или яйцо?

Warning: Ниже идёт пространное рассуждение автора, которое можно пропустить.

Теоретически в процессоре 6502 могут быть установлены одновременно команда выдачи регистра на шину и команда загрузки того же самого регистра из шины (например X/SB и SB/X).

![regs_nice_flow](/BreakingNESWiki/imgstore/regs_nice_flow.jpg)

Поэтому возникает резонный вопрос: что делать вначале - помещать регистр на шину (X/SB) или загружать его (SB/X)?

В данном случае транзисторы-ключи X/SB и SB/X будут открыты и получается что значение триггера просто "рефрешится" через шину.

По договоренности при симуляции триггеров значение с них вначале выдается потребителям, а потом загружается новое значение.

Поэтому команды выгрузки регистра на шину нужно делать перед командами загрузки новых значений.

Аналогичная ситуация может произойти например при выполнении инструкции TXS (поместить значение регистра X на регистр S). В этом случае рандомная логика выдаст две команды: X/SB и SB/S. При этом X/SB должна выполниться раньше SB/S, чтобы значение регистра X попало на шину SB, а с неё на регистр S.
