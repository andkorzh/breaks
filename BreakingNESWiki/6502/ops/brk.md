# BRK Последовательность

BRK-последовательность - это унифицированный механизм реакции процессора на внешние сигналы прерываний (`/NMI`, `/IRQ`, `/RES`), а также на выполнение инструкции `BRK` (0x00).

В основной части уже были упоминания о том, как разработчики подошли к унификации этого механизма (инжектирование кода операции 0x00 в регистр инструкций и проч.), в данном разделе производится более подробный анализ.

Дальнейшее рассмотрение состояния производится при учете, что вход `RDY` = 1 (процессор готов).

## Программная модель BRK

Информация общего плана для программистов, достаточная для общего понимания процесса BRK-последовательности.

|Цикл|Операция|
|---|---|
|T0|Загрузить опкод BRK (инструкция) / инжектировать BRK (прерывание). Инкремент PC, если выполняется непосредственно инструкция BRK|
|T1|Загрузить и задискардить данные. Инкремент PC, если выполняется непосредственно инструкция BRK|
|T2|Поместить PCH на стек|
|T3|Поместить PCL на стек|
|T4|Поместить P на стек|
|T5|Прочитать адрес вектора прерывания (младший байт)|
|T6|Прочитать адрес вектора прерывания (старший байт)|

## Сброс

### T0 (PHI1)

Верхняя часть:

|Состояние|Примечание|
|---|---|
|Обработчик прерываний||
|RESP=1|Это не эффект /RES=0, так как входной FF контакта /RES обновяется только во время PHI2. Это эффект выходной защелки resp_latch.|
|DORES=0|Входная защелка DORES_FF обновляется сигналом RESP только во время PHI2.|
|BRK6E=0|Значение выходной защелки не определено, поэтому через инвертор значение BRK6E принимает значение 0.|
|B_OUT=0|Хотя DORES = 0, но значение выходной защелки флага B не определено и BRK6E = 0, поэтому B_OUT = 0.|
|Диспатчер||
|/ready = 0|Значение выходной защелки /ready обновляется во время PHI2. На момент сброса значение защелки не определено, в результате чего /ready принимает значение 0.|
|WR=1|WR формируется операцией 3-NOR, входы которой (/ready, DORES, wr_latch) принимают значение 0. В результате чего WR = 1|
|FETCH=0|Значение выходной защелки схемы FETCH ещё не определено (обновляется во время PHI2).|
|0/IR=1|Т.к. FETCH = 0 и B_OUT = 0.|
|ENDS = 1|Значения выходных защелок схемы ENDS не определены.|
|TRES1 = 1|Т.к. ENDS = 1|
|TRESX=0|В состав схемы TRESX входит защелка, значение которой ещё не определено (PHI2). И через инвертор и NOR - TRESX в результате принимает значение 0.|
|/TWOCYCLE=1|PD=0x00|
|TRES2=1|Т.к. TRESX = 0|
|/T0 = 1|Соотв. схеме|
|/T1X = 0|Соотв. схеме|
|Расширенный счетчик циклов||
|/T2-/T5 = 1|TRES2 = 1|
|Декодер||
|44: INC NOP (TX), 60: ADC SBC (T1), 106: LSR ROR DEC INC DEX NOP (4x4 bottom right) (TX), 112: ADC SBC (T1)|Выполняет 0xFF/T1. Операция не имеет смысла, т.к. все выходные защелки рандомной логики обновляются только во время PHI2.|
|Регистры||
|PD=0x00|В результате 0/IR=1 значение PD = 0x00|
|IR=0xFF|Значение регистра IR не обновляется (FETCH = 0), при этом он устроен так, что на декодер попадает значение 0xFF|

Нижняя часть:

В результате того, что выходные командые защелки загружаются только во время PHI2 - их выходные значения сразу после сброса не определены.

Это приводит к тому, что практически все команды нижней части активны (отсутствие заряда на затворах выходных защелок приводит к тому, что на выходе у них 1). В этом случае нижняя часть "сходит с ума".

|Состояние|Примечание|
|---|---|
|ADH/ABH, ADL/ABL|Шина адреса принимает значение 0x0000|
|0/ADL0|1|
|0/ADL1|1|
|0/ADL2|0|
|0/ADH0, 0/ADH17|Обе активных команды приводят к тому, что на шине ADH значение 0x00.|
|Y/SB, SB/Y, X/SB, SB/X, S/ADL, S/SB, SB/S, S/S|Y/SB, X/SB, SB/S, S/S не приводят к эффекту, т.к. регистр обновляется только во время PHI2. В результате текущее значение регистров X, Y, S одновременно помещается на шину SB (для регистра S - также на шину ADL командой S/ADL). Особенность регистра S такая, что значение с выходной защелки выдается в инвертированном виде. То есть на шину SB и ADL помещается значение 0xFF (S = 0). Но так как до этого регистры X/Y уже поместили на шину значение 0x00 - побеждает земля и шина SB принимает значение 0x00|
|NDB/ADD, DB/ADD, 0/ADD, SB/ADD, ADL/ADD, ADD/SB06, ADD/ADL, SB/AC, AC/SB, AC/DB, SB/DB, SB/ADH|AI: Команды 0/ADD, SB/ADD приводят к эффекту загрузки 0 на защелку AI и одноврменному "заземлению" шины SB (SB/ADD открывает шину SB, а 0/ADD зануляет её). Но в этом нет смысла, т.к. SB уже заземлена регистровыми операциям. BI: Рассматривать нет смысла (?). Выход ALU: Рассматривать нет смысла (?). ADD/SB7 = 0 из-за особенностей её выходной защелки (но в ней тоже сейчас нет смысла)|
|Операции АЛУ|Все отключены|
|/ACIN|TBD|
|/DAA|TBD|
|/DSA|TBD|
|#1/PC|TBD|
|ADH/PCH, PCH/PCH, PCH/ADH, PCH/DB, ADL/PCL, PCL/PCL, PCL/ADL, PCL/DB|TBD|
|RD = 0|В соответствии с WR = 1|
|DL/ADL, DL/ADH, DL/DB|Одновременная установка команд DL/ADL и DL/ADH приводит к замыканию шин ADL/ADH, в результате чего они обе становятся равными 0x00 (ADH уже заземлена командами 0/ADH0, 0/ADH17). DL/DB приводит также к занулению шины DB. Защелка DOR = 0x00.|
|Внутренние шины||
|SB|0x00|
|DB|0x00|
|ADL|0x00|
|ADH|0x00|

Феномен: Все части процессора "сходят с ума", но чудесным образом в результате всех операции процессор делает запись 0x00 по адресу 0x0000.

### T0 (PHI2)

TBD.

## NMI

TBD.

## IRQ

TBD.

## Смешанное прерывание

Ситуация когда сразу несколько входных контактов прерываний фиксируют событие.

TBD.

## Инструкция BRK

TBD.

## Сброс RDY

Что происходит, если во время BRK-последовательности вход `RDY` становится равным 0 (процессор НЕ готов).

TBD.
